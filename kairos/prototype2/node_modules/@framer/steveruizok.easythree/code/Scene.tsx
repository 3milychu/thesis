import * as React from 'react'
import * as THREE from 'three'
import { PropertyControls, ControlType, FrameProperties } from 'framer'

interface UpdateParams {
	camera: THREE.Camera
	scene: THREE.Scene
	mouse: THREE.Vector2
	raycaster: THREE.Raycaster
}

type SceneEventHandler = (event: React.MouseEvent, params: UpdateParams) => void
type SceneLifeCycleHandler = (props: Props, params: UpdateParams) => void

// Define type of property
interface Props extends FrameProperties {
	text: string
	distance: number
	backgroundColor: string | Number
	height: number
	width: number
	camera: THREE.PerspectiveCamera
	onClick: SceneEventHandler
	onMouseEnter: SceneEventHandler
	onMouseLeave: SceneEventHandler
	onMouseMove: SceneEventHandler
	start?: SceneLifeCycleHandler
	update?: SceneLifeCycleHandler
}

export class Scene extends React.Component<Props> {
	container: React.RefObject<HTMLDivElement> = React.createRef()
	mouse = new THREE.Vector2(0, 0)
	scene = new THREE.Scene()
	raycaster = new THREE.Raycaster()
	renderer = new THREE.WebGLRenderer({ antialias: true })
	backgroundColor = new THREE.Color(this.props.backgroundColor)
	frameId = 0

	// Set default properties
	static defaultProps: Partial<Props> = {
		distance: 4,
		backgroundColor: '#ccccc0',
		onClick: () => {},
		onMouseMove: () => {},
		onMouseEnter: () => {},
		onMouseLeave: () => {},
		camera: new THREE.PerspectiveCamera(75, 1, 0.01, 1000),
		...getDefaults(),
	}

	// Items shown in property panel
	static propertyControls: PropertyControls = {
		backgroundColor: { type: ControlType.Color, title: 'Background' },
		distance: {
			type: ControlType.Number,
			title: 'Distance',
			min: 1,
			max: 5,
			step: 0.001,
			default: 1,
		},
	}

	componentDidMount() {
		const container = this.container.current

		this.renderer.setClearColor(this.backgroundColor)
		container.appendChild(this.renderer.domElement)
		container.addEventListener('mousemove', this.setMousePosition)

		this.handleResize(this.props)
		this.props.camera.lookAt(this.scene.position)

		this.props.start(this.props, {
			camera: this.props.camera,
			scene: this.scene,
			mouse: this.mouse,
			raycaster: this.raycaster,
		})
		this.frameId = requestAnimationFrame(this.update)
	}

	componentWillReceiveProps(props) {
		if (props !== this.props) {
			this.handleResize(props)
		}

		this.renderer.setClearColor(props.backgroundColor)
	}

	componentWillUnmount() {
		this.container.current.removeChild(this.renderer.domElement)
	}

	// helpers
	handleResize = (props: Props) => {
		const { distance, camera, height, width } = props
		const aspect = width / height
		camera.aspect = aspect
		camera.updateProjectionMatrix()
		camera.position.set(distance, distance, distance)
		this.renderer.setSize(width, height)
	}

	update = () => {
		this.props.update(this.props, {
			camera: this.props.camera,
			scene: this.scene,
			mouse: this.mouse,
			raycaster: this.raycaster,
		})
		this.renderer.render(this.scene, this.props.camera)
		requestAnimationFrame(this.update)
	}

	setMousePosition = (event: MouseEvent) => {
		if (!event.currentTarget) return

		const target = event.currentTarget as HTMLDivElement
		const { pageX, pageY } = event
		const { offsetLeft, offsetTop, offsetHeight, offsetWidth } = target

		this.mouse.x = ((pageX - offsetLeft) / offsetWidth) * 2 - 1
		this.mouse.y = -((pageY - offsetTop) / offsetHeight) * 2 + 1
	}

	render() {
		const args = {
			camera: this.props.camera,
			scene: this.scene,
			mouse: this.mouse,
			raycaster: this.raycaster,
		}

		return (
			<div
				ref={this.container}
				onClick={(event) => {
					this.props.onClick(event, args)
				}}
				onMouseEnter={(event) => {
					this.props.onMouseEnter(event, args)
				}}
				onMouseLeave={(event) => {
					this.props.onMouseLeave(event, args)
				}}
				onMouseMove={(event) => {
					this.props.onMouseMove(event, args)
				}}
				style={{ width: '100%', height: '100%' }}
			/>
		)
	}
}

// Default initial values

function getDefaults() {
	// Cube
	const cube = new THREE.Mesh(
		new THREE.BoxGeometry(1, 1, 1),
		new THREE.MeshStandardMaterial({
			color: 0xaaaaa0,
		})
	)

	const light = new THREE.DirectionalLight(0xfffff0, 0.5)
	light.position.set(50, 100, 150)

	return {
		start: (props: Props, { scene }) => {
			scene.add(cube)
			scene.add(light)
		},
		update: (props: Props, { scene, mouse }) => {
			cube.rotation.x -= mouse.y / 100
			cube.rotation.y += mouse.x / 100
		},
	}
}
