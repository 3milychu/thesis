import * as React from "react";
import { PropertyControls, ControlType } from "framer";

const style: React.CSSProperties = {
  height: "100%",
  width: "100%"
};

// Define type of property
interface Props {
  seed: number;
  Element_1: string;
  Element_2: string;
  Element_3: string;
  Element_4: string;
  Element_5: string;
  baseSize: number;
  rotationVariation: number;
  numColumns: number;
  numRows: number;
  xPadding: number;
  yPadding: number;
  xDisplacement: number;
  yDisplacement: number;
}

export class Kaleido extends React.Component<Props> {
  //
  // Set default properties
  static defaultProps = {
    seed: 1,
    Element_1: "",
    Element_2: "",
    Element_3: "",
    Element_4: "",
    Element_5: "",
    baseSize: 10,
    rotationVariation: 0,
    numColumns: 6,
    numRows: 8,
    xPadding: 10,
    yPadding: 10,
    xDisplacement: 5,
    yDisplacement: 5
  };

  // Items shown in property panel
  static propertyControls: PropertyControls = {
    seed: { type: ControlType.Number, title: "Seed", min: 1 },
    Element_1: { type: ControlType.File, allowedFileTypes: ["svg", "jpg", "jpeg", "png"] },
    Element_2: {
      type: ControlType.File,
      allowedFileTypes: ["svg", "jpg", "jpeg", "png"],
      hidden(props) {
        return props.Element_1 === ""; //props.locationType !== LocationType.Custom;
      }
    },
    Element_3: {
      type: ControlType.File,
      allowedFileTypes: ["svg", "jpg", "jpeg", "png"],
      hidden(props) {
        return props.Element_2 === ""; //props.locationType !== LocationType.Custom;
      }
    },
    Element_4: {
      type: ControlType.File,
      allowedFileTypes: ["svg", "jpg", "jpeg", "png"],
      hidden(props) {
        return props.Element_3 === ""; //props.locationType !== LocationType.Custom;
      }
    },
    Element_5: {
      type: ControlType.File,
      allowedFileTypes: ["svg", "jpg", "jpeg", "png"],
      hidden(props) {
        return props.Element_4 === ""; //props.locationType !== LocationType.Custom;
      }
    },
    baseSize: { type: ControlType.Number, title: "Size Variation"  min: 1, step:0.05},
    rotationVariation: { type: ControlType.Number, title: "Rotation Variation"  min: 0, max: 360, step:0.05},
    numColumns: { type: ControlType.Number, title: "Columns", min: 1 },
    xPadding: { type: ControlType.Number, title: "H. Spacing" },
    xDisplacement: { type: ControlType.Number, title: "H. Displacement" },
    numRows: { type: ControlType.Number, title: "Rows", min: 1 },
    yPadding: { type: ControlType.Number, title: "V. Spacing" },
    yDisplacement: { type: ControlType.Number, title: "V. Displacement" }
  };

  constructor(props) {
    super(props);
    this.wrapper = null;
    this.canvas = null;
    this.ctx = null;
    this.currentSeed = 0;
  }

  componentDidMount() {
    this.canvas = document.createElement("canvas");
    this.wrapper.appendChild(this.canvas);
    this.ctx = this.canvas.getContext("2d");
    this.kaleido();
  }

  componentWillReceiveProps(props) {
    // Refresh stuff
    this.currentSeed = this.props.seed;
    this.kaleido();
    //
  }

  // Clean up when component gets unmounted
  componentWillUnmount() {
    if (this.canvas) {
      this.canvas.parentElement.removeChild(this.canvas);
    }
  }

  async kaleido() {

    this.canvas.width = this.props.width;
    this.canvas.height = this.props.height;


    // Load the requested images
    var URLs = [
      this.props.Element_1,
      this.props.Element_2,
      this.props.Element_3,
      this.props.Element_4,
      this.props.Element_5
    ].filter(c => c !== "");

    var images = [];
    for (let i = 0; i < URLs.length; i++) {
      images[i] = await this.imagePromisedLoad(this.props["Element_" + (i + 1)]);
    }

    // Clear the canvas before drawing updated graphics
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // (Re)draw all the elements
    for (let y = 0; y < this.props.numRows; y++) {
      for (let x = 0; x < this.props.numColumns; x++) {

        const choonesImage = images[Math.floor(this.seededRandom(0, images.length))];
        let finalWidth = choonesImage.naturalWidth;
        let finalHeight = choonesImage.naturalHeight;
        let xDisplacement = 0;
        let yDisplacement = 0;

        // Check and adjust size variance
        if(this.props.baseSize>1){

          let sizeVariance = this.seededRandom(1, this.props.baseSize);

          if (this.seededRandom(0, 1) < 0.5) {
            finalWidth = finalWidth * sizeVariance;
            finalHeight = finalHeight * sizeVariance;
          } else {
            finalWidth = finalWidth / sizeVariance;
            finalHeight = finalHeight / sizeVariance;
          }
        }

        // Check and adjust size x displacement
        if(this.props.xDisplacement>0){
          xDisplacement = this.seededRandom(
            -this.props.xDisplacement / 2,
            this.props.xDisplacement / 2
          );
        }
        // Check and adjust size y displacement
        if(this.props.yDisplacement>0){
          yDisplacement = this.seededRandom(
            -this.props.yDisplacement / 2,
            this.props.yDisplacement / 2
          );
        }

        // make space for the first element tranlating the canvas...
        this.ctx.save();
        this.ctx.translate( finalWidth/2, finalHeight/2 );
          // ... then move the center relatively to the single element
          this.ctx.save();
          this.ctx.translate(
            (x * this.props.xPadding + xDisplacement),
            (y * this.props.yPadding + yDisplacement)
          );

          // Check and adjust rotation variation
          if(this.props.rotationVariation!==0){
            this.ctx.rotate(this.seededRandom(0,this.props.rotationVariation * Math.PI / 180));
          }
          // center back to the element's center
          this.ctx.translate( -finalWidth/2, -finalHeight/2 );

          this.ctx.drawImage(
            choonesImage,
            0,
            0,
            finalWidth,
            finalHeight
          );
          this.ctx.restore();
        this.ctx.restore();
      }
    }
  }


  // Seeded "random" function.
  // same parameters = same output image
  seededRandom(min, max) {
    min = min || 0;
    max = max || 1;
    let rnd;

    if (this.props.seed === undefined) {
      rnd = Math.random();
    } else {
      this.currentSeed = (this.currentSeed * 9301 + 49297) % 233280;
      rnd = this.currentSeed / 233280;
    }
    return min + rnd * (max - min);
  }

  imagePromisedLoad(src) {
    return new Promise((resolve, reject) => {
      let img = new Image();

      img.src = src;
      img.onload = () => resolve(img);
      img.onerror = reject;
    });
  }

  render() {
    return (
      <div
        style={style}
        ref={wrapper => {
          this.wrapper = wrapper;
        }}>
      </div>
    );
  }
}
